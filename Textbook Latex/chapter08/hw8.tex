\section{Exercises}
\label{section:datapathControl}
\graphicspath{ {./chapter08/FigHw} }

\begin{enumerate}
    \item \textbf{ (4 pts.)}
        Show how to eliminate the 4-bit 2:1 mux in the bit counter by assuming
        that the Y register had an asynchronous active low reset input. Consider
        the fact that the external world still needs the ability to hit a single
        button to reset the state of the entire circuit.

    \item  \textbf{ (6 pts.)}
        A control unit has been built with the following control word:

        \begin{tabular}{|c|c|c|c|c|}  \hline
            Reg A   & Reg B   & Reg P  & Mux M      \\ \hline
            00 hold & 00 hold & 1 hold & 1 Load 0   \\ \hline
            11 lsr  & 11 lsr  &        &            \\ \hline
            10 lsl  & 10 lsl  & 0 load & 0 Load Add \\ \hline
            01 load & 01 load &        &            \\ \hline
        \end{tabular}

        Regrettably, these setting were completely wrong.  In reality here is what the control word should
        have been:

        \begin{tabular}{|c|c|c|c|c|}  \hline
            Reg A   & Reg B   & Reg P  & Mux M      \\ \hline
            00 hold & 00 hold & 0 hold & 0 Load 0   \\ \hline
            01 lsr  & 01 lsr  &        &            \\ \hline
            10 lsl  & 10 lsl  & 1 load & 1 Load Add \\ \hline
            11 load & 11 load &        &            \\ \hline
        \end{tabular}

        The design team is in a total panic.
        The design team thinks that it will take weeks to straighten out the error,
        they claim that the control unit needs to be redesigned.  However, there is
        a cheap and easy solution.  Design some combinational
        logic to insert between the faulty control unit and the datapath in order
        to straighten out the bum control signals.  There is one error can be
        fixed by changing something in the datapath, no extra hardware is
        required.  Identify this error and its solution.

        \begin{onlysolution} \textbf{Solution: }
            The mux's control input was flipped. If we change which signal is on what input, the issue will be dealt with.

            To fix the others, we could use the following logic (A and B are the same)
            \begin{align*}
                A_1^* & = A_1 \otimes A_0 \\
                A_0^* & = A_0             \\
                M^*   & = M'
            \end{align*}
        \end{onlysolution}
    \item \textbf{ (8 pts.)}
        Modify the algorithm for the bit counting circuit so that it uses a
        two-line handshake to transmit the Y register.  The circuit should take
        the role of an active producer in the transmission of Y.  The circuit
        has four handshaking lines and two data lines.  Hint, a common
        error of students is to insert a three-state buffer on the output of
        the Y register to the outside world to prevent its transmission to
        the outside world until the value of Y is finalized.  Don't do this!
        If the outside world reads the value of Y before the circuit's signals
        are valid (via the send\_REQ signal) then its their own dumb fault.
        Just send the Y signal outside the datapath as is.

    \item \textbf{ (16 pts.)}
        A 8kx32 RAM is full of integer data.  Design a circuit to scan
        the RAM and find its smallest value.

        Turn in; an algorithm the datapath and control unit, the control word
        table, the memory input equations, and output equations.
        The control unit is to be implemented using a ones hot encoding.

        \begin{onlysolution}[fragile] \textbf{Solution: }
            For this, we need to further expand on section~\ref{8-sec:Minimum Search}

              \begin{verbatim}
1.  min = 0xFFFFFFFF;         // Set the min reg to largest 32-bit value
2.  for (i=0; i<8192; i++) {  // Search through the entire array
3.      MBR=RAM[i];           // Read a value from RAM
4.      if (MBR<min) then     // If MBR is smaller than min
5.          min = MBR;        //   then set min to the smallest value
6.  } // end for
\end{verbatim}
            \textbf{DP \& CU}\\
            \includegraphics[max width=\textwidth, center]{Sol8-4}
            \begin{tabular}{c|c|c|c|c|c}
                \textbf{State}   & enb    & Min Reg & Min mux    & Counter  & MBR Reg \\ \hline
                & 0      & 0 hold  & 0 load FF  & 00 hold  & 0 hold  \\ \hline
                & 1 read & 1 load  & 1 load RAM & 01 load  & 1 load  \\ \hline
                &        &         &            & 10 count &         \\ \hline
                &        &         &            & 11 reset &         \\ \hline
                &        &         &            &          &         \\ \hline
                \textbf{InitMin} & 0      & 1       & 0          & 00       & 0       \\ \hline
                \textbf{InitI}   & 0      & 0       & x          & 01       & 0       \\ \hline
                \textbf{CompC}   & 0      & 0       & x          & 00       & 0       \\ \hline
                \textbf{Read}    & 1      & 0       & x          & 00       & 1       \\ \hline
                \textbf{CompM}   & 0      & 0       & x          & 00       & 0       \\ \hline
                \textbf{NewMin}  & 0      & 1       & 1          & 01       & 0       \\ \hline
                \textbf{Inc}     & 0      & 0       & x          & 10       & 0       \\ \hline
                \textbf{Done}    & 0      & 0       & x          & 00       & 0       \\
            \end{tabular}\\
            \begin{tabular}{cc}
                \textbf{MIE}                      & \textbf{OE} \\
                {$
                    \begin{aligned}
                        D_{IM} & = 0                   \\
                        D_{II} & = Q_{IM}              \\
                        D_{CC} & = Q_{II} + Q_{I}      \\
                        D_{R}  & = Q_{CC} * IC         \\
                        D_{CM} & = Q_{R}               \\
                        D_{D}  & = Q_{CC} * IC'        \\
                        D_{NM} & = Q_{CM} * MC         \\
                        D_{I}  & = Q_{NM} + Q_{CM}*MC' \\
                \end{aligned}$} &
                {$
                    \begin{aligned}
                        Z_{ENB} & = Q_{R}            \\
                        Z_{RM}  & = Q_{IM}  + Q_{NM} \\
                        Z_{MM}  & = Q_{NM}           \\
                        Z_{C1}  & = Q_{I}            \\
                        Z_{C0}  & = Q_{II} + Q_{NM}  \\
                        Z_{MBR} & = Q_{R}
                \end{aligned}$}
            \end{tabular}
        \end{onlysolution}
    \item \textbf{ (16 pts.)}
        A 8kx32 RAM is full of integer data.  Design a
        circuit that determines the sum of the integers {\em between} addresses
        A and B.  The values of A and B are to be read in using a two-line
        handshake where the circuit is to act as a passive consumer.
        The sum is to be placed in a 32-bit register S.
        Turn in; an algorithm the datapath and control unit, the control word
        table, the memory input equations, and output equations.
        The control unit is to be implemented using a ones hot encoding.

        \begin{onlysolution}[fragile]  \textbf{Solution}

            \textbf{ Algorithm}
              \begin{verbatim}
while(REQ==0);
A = datain;
ACK=1;
while(REQ==1);
ACK=0;
while(REQ==0);
B = datain;
ACK=1;
while(REQ==1);
ACK=0;
S=0;
for(i=A; i<B; i++)  {
    MBR=RAM[i];
    S=S+MBR;
} // end for
\end{verbatim}

            \begin{figure}[H]
                \textbf{ DP \& CU} \\ % Keep it with the graphic
                \includegraphics[max width=\textwidth, center]{Sol8-5}
                \caption{The datapath and control to determine the sum between
                addresses A and B.}
            \end{figure}

            \textbf{Control Word}

            \begin{tabular}{l|l|l|l|l|l|l}
                STATE  & A      & B      & MUX          & S      & MBR    & counter \\ \hline
                & 0 hold & 0 hold & 0 pass 0     & 0 hold & 0 hold & 00 hold \\ \hline
                & 1 load & 1 load & 1 pass S+MBR & 1 load & 1 load & 01 UP   \\ \hline
                &        &        &              &        &        & 10 load \\ \hline
                &        &        &              &        &        &         \\ \hline
                Wait1A & 0      & 0      & 0            & 0      & 0      & 00      \\ \hline
                GetA   & 1      & 0      & 0            & 0      & 0      & 00      \\ \hline
                Wait2A & 0      & 0      & 0            & 0      & 0      & 00      \\ \hline
                Wait1B & 0      & 0      & 0            & 0      & 0      & 00      \\ \hline
                GetB   & 0      & 1      & 1            & 1      & 0      & 10      \\ \hline
                Wait2B & 0      & 0      & 0            & 0      & 0      & 00      \\ \hline
                For    & 0      & 0      & 0            & 0      & 0      & 00      \\ \hline
                Read   & 0      & 0      & 0            & 0      & 1      & 01      \\ \hline
                Inc    & 0      & 0      & 1            & 1      & 0      & 00      \\ \hline
                Done   & 0      & 0      & 0            & 0      & 0      & 00      \\
            \end{tabular}

            \begin{tabular}{ll}
                \textbf{MIE}                                  & \textbf{OE}                    \\
                $D_{Wait1a}= Q_{wait1a}req'$                  & $Z_{A} = Q_{getA}$             \\
                $D_{GetA } = Q_{wait1a}req$                   & $Z_{B} = Q_{getB}$             \\
                $D_{wait2a}= Q_{getA} + Q_{wait2A}req$        & $Z_{MUX} = Q_{getB} + Q_{Inc}$ \\
                $D_{wait1b}= Q_{wait2a}req' + Q_{wait1B}req'$ & $Z_{S} = Q_{getB} + Q_{Inc}$   \\
                $D_{GetB } = Q_{wait1b}req$                   & $Z_{MBR} = Q_{Read}$           \\
                $D_{wait2B}= Q_{GetB} + Q_{wait2b}req$        & $Z_{c1} = Q_{GetB}$            \\
                $D_{For  } = Q_{wait2B}req'$                  & $Z_{c0} = Q_{Read}$            \\
                $D_{Read } = Q_{For}LB$                       &                                \\
                $D_{Inc  } = Q_{Read}$                        &                                \\
                $D_{Done } = Q_{For}LB'$                      &                                \\
            \end{tabular}
        \end{onlysolution}

    \item  \textbf{ (16 pts.)}
        Design a circuit that repetitively looks at a 1-bit input X.
        Anytime X changes logic values increment an 8-bit
        register Y.
        Turn in; an algorithm the datapath and control unit, the control word
        table, the memory input equations, and output equations.
        The control unit is to be implemented using a ones hot encoding.
        \begin{onlysolution}[fragile]\par\textbf{Solution:} There are two approaches you
            could take to this problem. The first approach is to store the previous value
            and compare.\par
            \textbf{Algorithm}
              \begin{verbatim}
bool oldX;
while(1){
    oldX = X;
    while (oldX == X);
    Y = Y + 1;
}
\end{verbatim}
            \textbf{Datapath and Control}

            \includegraphics[max width=\textwidth, center, scale=0.8]{sol8-6}
            \filbreak
            \textbf{Control Words}

            \begin{tabular}{c|c|c}
                State & Reg A  & Counter \\ \hline
                & 0 Hold & 00 Hold \\ \hline
                & 1 Load & 01 Inc  \\ \hline
                &        & 10 Load \\ \hline
                &        &         \\ \hline
                INIT  & 1      & 10      \\ \hline
                Read  & 0      & 00      \\ \hline
                Comp  & 1      & 01      \\ \hline
            \end{tabular}

            \begin{tabular}{cc}
                \textbf{MIE}                                    & \textbf{OE} \\
                {$
                    \begin{aligned}
                        D_{Read} & = Q_{INIT} + Q_{Read}E + Q_{Comp} \\
                        D_{Comp} & = Q_{Read}E'
                \end{aligned}$} &
                {$
                    \begin{aligned}
                        Z_{A}   & = Q_{INIT} + Q_{Comp} \\
                        Z_{C_1} & = Q_{INIT}            \\
                        Z_{C_0} & = Q_{Comp}
                \end{aligned}$}
            \end{tabular}\par
            An alternate way you could solve it would be to encode it all as state.\par % This isn't a good description
              \begin{verbatim}
while(1){
    if (X == 0){
        while(X == 0);
        Y++;
    }
    if (X == 1){
        while(X == 1);
        Y++;
    }
}
\end{verbatim}
            \includegraphics[max width=\textwidth, center, scale=0.75]{sol8-6alt}
            \filbreak
            \textbf{Control Words}

            \begin{tabular}{c|c}
                State     & Counter \\ \hline
                & 00 Hold \\ \hline
                & 01 Inc  \\ \hline
                & 10 Load \\ \hline
                &         \\ \hline
                INIT      & 10      \\ \hline
                $0$       & 00      \\ \hline
                $1$       & 00      \\ \hline
                $0\to1$   & 01      \\ \hline
                $0\gets1$ & 01      \\
            \end{tabular}

            \begin{tabular}{cc}
                \textbf{MIE}                                        & \textbf{OE} \\
                {$
                    \begin{aligned}
                        D_{0}       & = Q_{INIT}X' + Q_0X' + Q_{0\gets1} \\
                        D_{1}       & = Q_{INIT}X\,+ Q_1X\,+ Q_{0\to1}   \\
                        D_{0\to1}   & = Q_{0}X                           \\
                        D_{0\gets1} & = Q_{1}X'
                \end{aligned}$} &
                {$
                    \begin{aligned}
                        Z_{C_1} & = Q_{INIT}                \\
                        Z_{C_0} & = Q_{0\to1} + Q_{0\gets1}
                \end{aligned}$}
            \end{tabular}\\
        \end{onlysolution}
    \item \textbf{ (16 pts.)}
        A 256x8 RAM is full of data.  Design a circuit that jumps
        around in memory.  It does this by fetching a word and using the
        retrieved word as the next address to jump to.  The circuit is to
        start at address 0.
        Turn in; an algorithm the datapath and control unit, the control word
        table, the memory input equations, and output equations.
        The control unit is to be implemented using a ones hot encoding.

        To desired behavior of the circuit is illustrates in
        Figure~\ref{fig:RAMhopper}.  If the address=0 then the circuit will
        jump to address 3F then 28, 53, 3F and continue cycling
        for ever amount these three addresses.

        \begin{figure}[ht]
            \center{\includegraphics{Prob8-7}}
            \caption{A 256x8 RAM loaded with some data.}
            \label{fig:RAMhopper}
        \end{figure}
        \begin{onlysolution}[fragile]
            \textbf{Algorithm}
              \begin{verbatim}
Addr = 0;
while(1){
    Addr = RAM[Addr];
}
\end{verbatim}
            \filbreak
            \textbf{Datapath and Control}\\
            \includegraphics[max width=\textwidth, center]{Sol8-7}
            \textbf{Control Words}\par
            \begin{tabular}{c|c|c}
                State & Reg A  & Mux   \\ \hline
                & 0 Hold & 0 0   \\ \hline
                & 1 Load & 1 RAM \\ \hline
                &        &       \\ \hline
                INIT  & 1      & 0     \\ \hline
                Loop  & 1      & 1     \\
            \end{tabular}

            \begin{tabular}{cc}
                \textbf{MIE}                   & \textbf{OE} \\
                {$
                    \begin{aligned}
                        D_{Loop} = Q_{Init} + Q_{Loop}
                \end{aligned}$} &
                {$
                    \begin{aligned}
                        Z_A & = 1        \\
                        Z_M & = Q_{Loop}
                \end{aligned}$}
            \end{tabular}\\
        \end{onlysolution}
    \item \textbf{ (16 pts.)}
        A 256x8 RAM is full of data.  Design a circuit that jumps
        around in memory.   The current address should be stored in a
        register called PC.  If the MSB of the fetched word is 1, then the
        remaining seven bits represent a 7-bit 2's complement number;  add these
        seven bits to the PC.  If the MSB of the fetched word is 0 then just
        increment the PC.  Repeat this process forever.
        Turn in; an algorithm the datapath and control unit, the control word
        table, the memory input equations, and output equations.
        The control unit is to be implemented using a ones hot encoding.

        The desired behavior of the circuit is illustrated in
        Figure~\ref{fig:RAMhopper2}.  In this figure if PC=0 then the word at
        that address (3F) has a MSB of 0 so the PC is incremented to 1. The
        word at address 1 is fetched (BC) and has an MSB of 1 so the least
        significant seven bits of BC are added to the PC, making its new value
        3D.  repeating this process sees the PC goto address 21, 22, 21, 22
        into a never ending cycle.   Make sure the solution identifies how
        to add the least significant seven bits to an 8-bit PC.

        \begin{figure}[ht]
            \center{\includegraphics{Prob8-8}}
            \caption{A 256x8 RAM loaded with some data.}
            \label{fig:RAMhopper2}
        \end{figure}

        \begin{onlysolution}[fragile]\filbreak  \textbf{Solution}\par
            \textbf{Algorithm}
              \begin{verbatim}
int PC = 0;
int dat = 0;
while(1){
    dat = RAM[PC];
    if (dat[7] == 1){
        dat[7] = dat[6] // copy MSB of 2's comp number
        PC += dat;
    }
    else{
        PC++;
    }
}
\end{verbatim}
            \textbf{Datapath and Control}
            \begin{figure}[H]
                \includegraphics[max width=\textwidth, center]{Sol8-8}
                \caption{The datapath and control to conditionally hop around
                in RAM.}
            \end{figure}

            \textbf{Control Words}

            \begin{tabular}{l|l|l|l}
                STATE & MUX        & MBR    & PC     \\ \hline
                & 0 pass 1   & 0 hold & 0 hold \\ \hline
                & 1 pass MBR & 1 load & 1 load \\ \hline
                &            &        &        \\ \hline
                READ  & x          & 1      & 0      \\ \hline
                MSB?  & x          & 0      & 0      \\ \hline
                INC   & 0          & 0      & 1      \\ \hline
                MBR   & 1          & 0      & 1      \\
            \end{tabular}

            \begin{tabular}{cc}
                \textbf{MIE}       & \textbf{OE} \\
                {$
                    \begin{aligned}
                        D_{read} & = Q_{mbr}+Q_{inc} \\
                        D_{msb}  & = Q_{read}        \\
                        D_{inc}  & = Q_{msb} m'      \\
                        D_{mbr}  & = Q_{msb} m
                \end{aligned}$} &
                {$
                    \begin{aligned}
                        Z_{re}  & = Q_{read} \\
                        Z_{cs}  & = Q_{read} \\
                        Z_{MUX} & = Q_{mbr}  \\
                        Z_{mbr} & = Q_{read}
                \end{aligned}$}
            \end{tabular}\\
        \end{onlysolution}

    \item \textbf{ (16 pts.)}
        Modify the circuit in the previous problem as follows.  Anytime
        an external input, called IRQ, is asserted the circuit is to stop
        jumping around and ACK.  The outside world will then read
        the PC (which must be routed outside the datapath) and then drop the
        IRQ.  The circuit should then drop the ACK and resume jumping.
        Turn in; an algorithm the datapath and control unit, the control word
        table, the memory input equations, and output equations.
        The control unit is to be implemented using a ones hot encoding.
        \begin{onlysolution}[fragile]
            \textbf{Algorithm}
\begin{verbatim}
int PC = 0;
int dat = 0;
while(1){
    dat = RAM[PC];
    if (dat[7] == 1){
        dat[7] = dat[6] // copy MSB of 2's comp number
        PC += dat;
    }
    else{
        PC++;
    }

    if (IRQ){
        ACK = 1;
        while(IRQ);
        ACK = 0;
    }
}
\end{verbatim}
            \textbf{Datapath and Control}\par

            \includegraphics[max width=\textwidth, center]{Sol8-9}

            \textbf{Control Words}

            \begin{tabular}{l|l|l|l}
                STATE & MUX        & MBR    & PC     \\ \hline
                & 0 pass 1   & 0 hold & 0 hold \\ \hline
                & 1 pass MBR & 1 load & 1 load \\ \hline
                &            &        &        \\ \hline
                READ  & x          & 1      & 0      \\ \hline
                MSB?  & x          & 0      & 0      \\ \hline
                INC   & 0          & 0      & 1      \\ \hline
                MBR   & 1          & 0      & 1      \\
            \end{tabular}

            \begin{tabular}{cc}
                \textbf{MIE}                                           & \textbf{OE} \\
                {$
                    \begin{aligned}
                        D_{read} & = Q_{mbr}IRQ'+Q_{inc}IRQ' + Q_{wait}IRQ' \\
                        D_{msb}  & = Q_{read}                               \\
                        D_{inc}  & = Q_{msb} m'                             \\
                        D_{mbr}  & = Q_{msb} m                              \\
                        D_{wait} & = Q_{mbr}IRQ + Q_{inc}IRQ + Q_{wait}IRQ
                \end{aligned}$} &
                {$
                    \begin{aligned}
                        Z_{re}  & = Q_{read} \\
                        Z_{cs}  & = Q_{read} \\
                        Z_{MUX} & = Q_{mbr}  \\
                        Z_{mbr} & = Q_{read} \\
                        Z_{ACK} & = Q_{wait}
                \end{aligned}$}
            \end{tabular}\\
        \end{onlysolution}

    \item  \textbf{ (16 pts.)} Design a circuit that reads successive words from
        a 1kx12 RAM and updates a 12-bit register called \textbf{ACC} based on
        the upper two bits of the memory word.  The address of the current
        memory word should be contained in a register called PC (Program
        Counter).  Since the words read from the RAM will tell us what
        operation to perform on the ACC, the memory word will be stored in a
        register called IR (Instruction Register).  If the upper two bits of
        IR are:
        \begin{enumerate}
            \item  00 then add the lower ten bits of the IR to ACC.  Pad the
                upper two bits of the IR with 0's before adding to ACC.
            \item  01 then store ACC to the address specified by the lower ten
                bits of the IR.
            \item  10 then load the ACC from from the address specified by the
                lower ten bits of the IR.
            \item  11 then clear the value of ACC to 0.
        \end{enumerate}

        The PC is to be initialized to 0.  After the each memory word is read
        and the appropriate operation performed on ACC, the PC should be
        incremented.
        Turn in; an algorithm the datapath and control unit, the control word
        table, the memory input equations, and output equations.
        The control unit is to be implemented using a ones hot encoding.

        \begin{onlysolution}[fragile]  \textbf{Solution}\par
            \textbf{ Algorithm}
              \begin{verbatim}
PC = 0;
while(1) {
    IR = RAM[PC];
    if (IR[11:10] == 0b00)
        ACC += 00 & IR[9:0];
    if (IR[11:10] == 0b01)
        RAM[IR[9:0]] = ACC;
    if (IR[11:10] == 0b10)
        ACC = RAM[IR[9:0]];
    if (IR[11:10] == 0b11)
        ACC = 0;
    PC += 1;
}
\end{verbatim}
            \textbf{Datapath and Control}\par
            \includegraphics[max width=\textwidth, center]{Sol8-10}
            \textbf{Control Word}\vspace{0.5em}

            \centerline{\resizebox{0.9\textwidth}{!}{
                    \begin{tabular}{l|l|l|l|l|l|l|l|l}
                        State & ACC mux & Acc    & IR     & TSB    & PC      & Addr Mux & CS   & R/W'    \\ \hline
                        & 00 add  & 0 hold & 0 hold & 0 Z    & 00 hold & 0 PC     & 0 no & 0 write \\ \hline
                        & 01 0    & 0 load & 0 load & 1 pass & 01 load & 1 IR     & 0 on & 1 read  \\ \hline
                        & 10 RAM  &        &        &        & 10 up   &          &      &         \\ \hline
                        &         &        &        &        &         &          &      &         \\ \hline
                        Init  & 01      & 1      & 0      & 0      & 01      & x        & 0    & x       \\ \hline
                        Read  & xx      & 0      & 1      & 0      & 00      & 0        & 1    & 1       \\ \hline
                        Comp  & xx      & 0      & 0      & 0      & 00      & x        & 0    & x       \\ \hline
                        Add   & 00      & 1      & 0      & 0      & 00      & x        & 0    & x       \\ \hline
                        Stor  & xx      & 0      & 0      & 1      & 00      & 1        & 1    & 0       \\ \hline
                        Load  & 10      & 0      & 0      & 0      & 00      & 1        & 1    & 1       \\ \hline
                        Clr   & 01      & 1      & 0      & 0      & 00      & x        & 0    & x       \\ \hline
                        Inc   & xx      & 0      & 0      & 0      & 10      & x        & 0    & x       \\
                    \end{tabular}
            }}
            \begin{tabular}{cc}
                \textbf{MIE}                                    & \textbf{OE} \\
                {$
                    \begin{aligned}
                        D_{Init} & = Q_{wait1a}req'                  \\
                        D_{Read} & = Q_{wait1a}req                   \\
                        D_{Comp} & = Q_{getA} + Q_{wait2A}req        \\
                        D_{Add}  & = Q_{wait2a}req' + Q_{wait1B}req' \\
                        D_{Stor} & = Q_{wait1b}req                   \\
                        D_{Load} & = Q_{GetB} + Q_{wait2b}req        \\
                        D_{Clr}  & = Q_{wait2B}req'                  \\
                        D_{Inc}  & = Q_{For}LB
                \end{aligned}$} &
                {$
                    \begin{aligned}
                        Z_{m1}   & = Q_{load}                     \\
                        Z_{Init} & = Q_{Clr}                      \\
                        Z_{Acc}  & = Q_{Init} + Q_{Add} + Q_{Clr} \\
                        Z_{IR}   & = Q_{Read}                     \\
                        Z_{TSB}  & = Q_{Stor}                     \\
                        Z_{PC1}  & = Q_{Inc}                      \\
                        Z_{PC0}  & = Q_{Init}                     \\
                        Z_{CS}   & = Q_{Read}+Q_{Stor}+Q_{Load}   \\
                        Z_{Amux} & = Q_{Read}+Q_{Stor}+Q_{Load}   \\
                        Z_{RW}   & = Q_{Read}+Q_{Load}
                \end{aligned}$}
            \end{tabular}
        \end{onlysolution}

    \item \textbf{ (16 pts.)}
        Design a circuit that moves $M$ consecutive words from address $S$ (source) to
        address $D$ (destination).  For example, if $M=4$, $S=3EA$ and $D=1FE$ then the
        circuit would move words 3EA, 3EB, 3EC and 3ED to address 1FE, 1FF, 200 and 201.
        Each of $M,S,D$ is preloaded into a register.  While this problem appears simple,
        its really rather treacherous.  The circuit will have to handle cases where
        $S+M > D$.  In such a case the order of the data movement must be carefully planned.
        In order to simplify the design, assume that $S<D$.
        Turn in; an algorithm the datapath and control unit, the control word
        table, the memory input equations, and output equations.
        The control unit is to be implemented using a ones hot encoding.
        Do not worry about the sizes of the
        registers or RAM.
        \begin{onlysolution}[fragile]\textbf{Solution}\par
            \textbf{Algorithm}
\begin{verbatim}
//Fill back to front to avoid overwriting unseen
int cdst = D + M;
for (int loc = S + M; loc >= S; loc--){
    RAM[cdst] = RAM[loc];
}
\end{verbatim}
            \textbf{Datapath and Control}
            %\includegraphics[max width=\textwidth, center]{Sol8-11}
            \textbf{Control Words}
            \begin{tabular}{c}
            \end{tabular}
            \begin{tabular}{cc}
                \textbf{MIE} & \textbf{OE} \\
                {$
                    \begin{aligned}
                \end{aligned}$} &
                {$
                    \begin{aligned}
                \end{aligned}$}
            \end{tabular}\\
        \end{onlysolution}

    \item \textbf{ (16 pts.)}
        Design a circuit that determines how many times a user
        specified 8-bit value, called \textbf{key}, occurs in an 1kx8 RAM.
        \textbf{key} is to be read using a two-line handshake; the circuit
        is the passive consumer.
        Turn in; an algorithm the datapath and control unit, the control word
        table, the memory input equations, and output equations.
        The control unit is to be implemented using a ones hot encoding.

        \begin{onlysolution}[fragile]\textbf{Solution}\par
            \textbf{Algorithm}
\begin{verbatim}
int count = 0;
while(REQ == 0);
ACK = 1;
int key = INPUT;
while(REQ == 1);
ACK = 0;
for (int loc = 0; loc < 1024; loc++){
    if (RAM[loc] == key){
        count++;
    }
}
\end{verbatim}
            \textbf{Datapath and Control}\par
            %\includegraphics[max width=\textwidth, center]{Sol8-12}

            \textbf{Control Words}
            \begin{tabular}{c}
            \end{tabular}
            \begin{tabular}{cc}
                \textbf{MIE} & \textbf{OE} \\
                {$
                    \begin{aligned}
                \end{aligned}$} &
                {$
                    \begin{aligned}
                \end{aligned}$}
            \end{tabular}\\
        \end{onlysolution}

    \item \textbf{ (16 pts.)} Design a circuit that records the number of times that it
        has seen an 8-bit, user specified value, \textbf{ key}.  The key will
        is shown to the circuit, at most, 16 times.  The collection of
        keys is stored in a 1kx12 RAM.  The RAM is larger
        than it needs to be because it is thought that in the future
        the number of keys will be increased.  Each word of the RAM is
        organized as follows; The upper eight bits hold the key and the lower
        four bits hold the ``hit count", the number of times that this key has
        been seen.  The circuit should read in the key using a two-line
        handshake; the circuit is the passive consumer.  The circuit
        should then scan the RAM looking for a matching key; a match, if
        it exists, will only occur once in the RAM.  If a match is
        found then increment the lower four bit and store the key and the
        incremented hit count back to RAM.
        Turn in; an algorithm the datapath and control unit, the control word
        table, the memory input equations, and output equations.
        The control unit is to be implemented using a ones hot encoding.
        \begin{onlysolution}[fragile]\textbf{Solution}\par
            \textbf{Algorithm}
        \begin{verbatim}
\end{verbatim}
            \textbf{Datapath and Control}

            \includegraphics[max width=\textwidth, center]{Sol8-13}

            \textbf{Control Words}

            \begin{tabular}{c}
            \end{tabular}

            \begin{tabular}{cc}
                \textbf{MIE} & \textbf{OE} \\
                {$
                    \begin{aligned}
                \end{aligned}$} &
                {$
                    \begin{aligned}
                \end{aligned}$}
            \end{tabular}\\
        \end{onlysolution}
    \item \textbf{ (36 pts.)}
        Design a digital circuit to control access to an
        automated parking garage containing 828 parking spaces.
        Drivers pull up to the garages gate and insert
        their pass card into a card reader.  The card reader sends the pass card
        ID number to the digital circuit.  If their pass card has a valid
        code then the gate opens.  There is a pressure sensor just inside the
        entry way which sends a signal to the circuit whenever a significant
        load is present (over 150 lbs).
        The exit procedure is similar, the users have to insert their pass card
        into a card reader.  The digital circuit then raises the exit gate bar,
        a pressure sensor at the exit tells the circuit when it is OK to close
        the exit gate.  See Figure~\ref{fig:Garage}.
        \begin{figure}[ht]
            \includegraphics[max width=\textwidth, center]{Prob8-14}
            \caption{The layout of an automated garage.}
            \label{fig:Garage}
        \end{figure}

        The signal names are defined in the following table:

        \begin{tabular}{|l|l||l|l|} \hline
            Entrance gate   & InGate  & 0 Close gate                         & 1 Open gate            \\ \hline
            Entrance sensor & InSen   & 0 No weight                          & 1 Weight present       \\ \hline
            Entrance REQ    & InREQ   & 0 No card read data                  & 1 Card reader has data \\ \hline
            Entrance ACK    & InACK   & \multicolumn{2}{c|}{Circuit control}                          \\ \hline
            Entrance ID     & InID    & \multicolumn{2}{c|}{Card ID}                                  \\ \hline
            Exit gate       & OutGate & 0 Close gate                         & 1 Open gate            \\ \hline
            Exit sensor     & OutSen  & 0 No weight                          & 1 Weight present       \\ \hline
            Exit REQ        & OutREQ  & 0 No card read data                  & 1 Card reader has data \\ \hline
            Exit ACK        & OutACK  & \multicolumn{2}{c|}{Circuit control}                          \\ \hline
            Exit ID         & OutID   & \multicolumn{2}{c|}{Card ID}                                  \\ \hline
        \end{tabular}

        The gate requires a logic 1 to start and to stay open. The sensor will
        generate a logic 1 while there is more than 150 lbs. on the sensor.  Only
        close the gate when the rear wheels of the car activate the
        sensor (hope no unicycle use the garage).  The entrance card reader
        will provide InID or OutID using a
        two-line handshake, where the circuit is the passive consumer.
        Assume that at any point in time only one car is
        entering or leaving the garage.  That is, deal with only
        one direction at a time.

        In addition to controlling access to the garage, the clients would also
        like to keep track track of how many times a pass ID has been used to
        gain access in-to and out-of the garage.  The count will be checked and
        reset once a month.  Cars pass into and out of the garage at most 4
        times a day.

        To implement this circuit use a \textit{ single} RAM.  Each word of the
        RAM must be divided into three fields; ID, Ins and Outs corresponding to
        the pass ID number, number of times into the garage and number of times
        out of the garage respectively.   The digital circuit will scan successive
        IDs in the RAM looking for a match.  If a match
        is found then either increment the Ins or Outs field then store this
        item back into the RAM.  A major issue in this design is determining
        the sizes of the data items.  Use the information in the word statement
        to make the design as space efficient as possible.
        \begin{figure}[ht]
            \center{\includegraphics{Prob8-14b}}
            \caption{The format of the RAM in the garage circuit problem.}
            \label{fig:GarRAM}
        \end{figure}
        Turn in; an algorithm the datapath and control unit, the control word
        table, the memory input equations, and output equations.
        The control unit is to be implemented using a ones hot encoding.

        \begin{onlysolution}[fragile]\textbf{Solution}\par
            \textbf{Algorithm}
        \begin{verbatim}
\end{verbatim}
            \textbf{Datapath and Control}

            \includegraphics[max width=\textwidth, center]{Sol8-14}

            \textbf{Control Words}

            \begin{tabular}{c}
            \end{tabular}

            \begin{tabular}{cc}
                \textbf{MIE} & \textbf{OE} \\
                {$
                    \begin{aligned}
                \end{aligned}$} &
                {$
                    \begin{aligned}
                \end{aligned}$}
            \end{tabular}
            \filbreak
        \end{onlysolution}
    \item \textbf{ (16 pts.)} Design a circuit that converts a 6-bit binary number into a 2
        digit BCD representation.  The circuit acquires a 6-bit number through
        a two-line handshake where the circuit is a passive consumer.  The
        circuit is then to convert this 6-bit number into two BCD digits and
        signals it completion via a DONE signal.

        A number X can be converted from binary into BCD digits by iteratively
        checking that X is greater than 10, then subtracting 10 from X.  Each
        subtraction should increment a tens digit counter.

        Make sure to identify the size of all the signals in the datapath
        and the size of any register, counters, etc...
        Turn in; an algorithm the datapath and control unit, the control word
        table, the memory input equations, and output equations.
        The control unit is to be implemented using a ones hot encoding.

    \item \textbf{ (8 pts.)}
        Design a circuit that converts a 2 digit BCD number into a
        binary number.  The circuit acquires the BCD digits through 2 read
        operations most significant digit first.  Each read operation takes
        the form of a two-line handshake where the circuit is a passive
        consumer.

        A 2 digit BCD number can be converted into binary by multiplying the
        most significant digit by 10 then adding it to the least significant
        BCD digit.  A number can be multiplied by 10 using the shift-and-add
        technique presented on page~\pageref{6-page:MulyBy10}.  Note, this
        task can be accomplished without using a single shift register.
        For example, the adder in Figure~\ref{fig:NineTimes} generates the value
        of 9*X from a 4-bit register by adding X, shifted left by three bits, to X.

        \begin{figure}[ht]
            \center{\includegraphics{Prob8-16}}
            \caption{A simple circuit to compute 9*X.}
            \label{fig:NineTimes}
        \end{figure}

        Make sure to identify the size of all the signals in the datapath
        and the size of any register, counters, etc...
        Turn in; an algorithm the datapath and control unit, the control word
        table, the memory input equations, and output equations.
        The control unit is to be implemented using a ones hot encoding.
        \begin{onlysolution}\par
            \includegraphics[max width=\textwidth, center]{Sol8-13}
        \end{onlysolution}
    \item \textbf{ (36 pts.)}
        Design a digital circuit that plays a game of
        roulette, allows betting and keeps track of total earnings.
        The roulette wheel has 8 slots, labeled $1 \ldots 8$.  The player
        can play one of the numbers straight or play even or odd.
        The player starts with \$10.
        The layout of the machine is shown in Figure~\ref{fig:Roulette}.
        \begin{figure}[ht]
            \center{\includegraphics{Prob8-17}}
            \caption{The layout of the roulette playing machine.
                The two 7-segment displays at the top are used for a variety
            of purposes.}
            \label{fig:Roulette}
        \end{figure}

        The sequence of events is as follows:
        \begin{enumerate}
            \item    The circuit lights up the PICK LED.
                The player enters their guess; a number between 1-8, even or odd.
                While holding down their guess they press the roll button.
            \item    The circuit displays the picked number in the left most
                7-segment display.  The circuit lights up the BET LED.
                The player enters a one digit bet between 1 to 8.  While holding
                down their bet they press the roll button.
            \item     The circuit displays the bet on the rightmost 7-segment
                display.
                The player pushes and holds down the roll button.
                The circuit increments a mod 8 counter while the roll
                button is depressed. It would be nice to display the
                current count value on right 7-seven segment display.
                Since the clock cycle is on the order of milliseconds,
                then the user would not be able to anticipate the roll.
            \item    The player releases the roll button.  The final roll
                is displayed on the rightmost 7-segment display.
                The circuit stops incrementing the counter and checks
                to see if the final value matches the players guess.
                If the match is correct then light the WIN LED and
                increment the players earnings.  If the match is incorrect
                then light the LOOSE LED and decrement the players
                earnings.
            \item    The play hits the roll button to clear the roll information
                from the 7-segment displays.
            \item    The circuit displays the players earnings on the 7-segment
                display.
            \item    When the user pushes the roll button then go to step 1.
        \end{enumerate}

        Set reasonable bounds on the maximum winnings.  Values may be displayed
        in hexadecimal (assume there is a hex to 7-segment display converter
        available).  See page~\pageref{page:7seg} for more
        information.
        Turn in; an algorithm the datapath and control unit, the control word
        table, the memory input equations, and output equations.
        The control unit is to be implemented using a ones hot encoding.

        \begin{onlysolution}[fragile]  \textbf{Solution}

            \textbf{ Algorithm}
              \begin{verbatim}
cash = 10;
left_seven = blank;
right_seven = cash;
while(cash > 0) {
    led_array = 1 0 0 0;    // Pick Bet Win Loose
    while(ROLL == 0);
    guess = Datain;
    while(ROLL == 1);

    led_array = 0 1 0 0;    // Pick Bet Win Loose
    left_seven = guess;
    right_seven = blank;
    while(ROLL == 0);
    bet = Datain;
    while(ROLL == 1);

    led_array = 0 0 0 0;    // Pick Bet Win Loose
    right_seven = bet;
    while(ROLL == 0);
    while(ROLL == 1) count = count + 1;

    right_seven = count;
    if (count == guess) {
            cash = cash + (bet << 2);
            led_array = 0 0 1 0;    // Pick Bet Win Loose
        } else {
                cash = cash - bet;
                led_array = 0 0 0 1;    // Pick Bet Win Loose
            }
            while(ROLL == 0);
            while(ROLL == 1);
            right_seven = cash;

        }
        led_array = 0 0 0 1;    // The user is out of money
        while(1);        // Halt the machine
\end{verbatim}
            \textbf{ Datapath and Control}

            \begin{figure}[ht]
                \includegraphics[max width=\textwidth, center]{Sol8-16}
            \end{figure}
            \filbreak
            Note from the figure that, the user may acquire
            up to 0xFF cash.  Each hex digit of the users total cash will
            be displayed on its own 7-segment display.

            \textbf{ Control Word}

            \centerline{\scalebox{0.85}{ %Center align table, ignoring margins. The full-sized table fits like this, however I think that it looks
                    \begin{tabular}{l|l|l|l|l|l|l|l|l|l|l}
                        State  & counter  & guess  & bet    & cmux      & bmux         & cash   & add/sub & ledmux
                        & rmux     & lmux                                                                            \\ \hline
                        & 00 hold  & 0 hold & 0 hold & 0 \$10    & 0 bet        & 0 hold & 0 add   & 00 (pick)  & 00
                        cash   & 00 cash                                                                                    \\ \hline
                        & 01 load  & 0 load & 1 load & 1 add/sub & 1 bet$\,<<$2 & 1 load & 1 sub   & 01 (bet)   & 01
                        bet    & 01 guess                                                                                   \\ \hline
                        & 10 up    &        &        &           &              &        &         & 10 (win)   & 10
                        count  & 10 blank                                                                                   \\ \hline
                        &          &        &        &           &              &        &         & 11 (loose) & 11
                        blank  &                                                                                            \\ \hline
                        &          &        &        &           &              &        &         &            &
                        &                                                                                            \\ \hline
                        init   & 00       & 0      & 1      & 0         & x            & 1      & x       & 00
                        & 11       & 11                                                                              \\ \hline
                        wg1    & 00       & 0      & 0      & x         & x            & 0      & x       & 00
                        & 00       & 00                                                                              \\ \hline
                        guess  & 00       & 1      & 0      & x         & x            & 0      & x       & 00
                        & 11       & 01                                                                              \\ \hline
                        wg2    & 00       & 0      & 0      & x         & x            & 0      & x       & 00
                        & 11       & 01                                                                              \\ \hline
                        wb1    & 00       & 0      & 0      & x         & x            & 0      & x       & 01
                        & 11       & 01                                                                              \\ \hline
                        bet    & 01       & 0      & 1      & x         & x            & 0      & x       & 01
                        & 11       & 01                                                                              \\ \hline
                        wb2    & 00       & 0      & 0      & x         & x            & 0      & x       & 00
                        & 01       & 01                                                                              \\ \hline
                        wr1    &          &        &        & x         & x            &        & x       &
                        &          &                                                                                 \\ \hline
                        spin   & 10       & 0      & 0      & x         & x            & 0      & x       & 00
                        & 10       & 01                                                                              \\ \hline
                        load 1 & 01       & 0      & 0      & x         & x            & 0      & x       & 00
                        & 10       & 01                                                                              \\ \hline
                        comp   & 00       & 0      & 0      & x         & x            & 0      & x       & 00
                        & 10       & 01                                                                              \\ \hline
                        win    & 00       & 0      & 0      & 1         & 1            & 1      & 0       & 10
                        & 10       & 01                                                                              \\ \hline
                        add    &          &        &        &           &              &        &         &
                        &          &                                                                                 \\ \hline
                        loose  & 00       & 0      & 0      & 1         & 0            & 1      & 1       & 11
                        & 10       & 01                                                                              \\ \hline
                        sub    &          &        &        &           &              &        &         &
                        &          &                                                                                 \\ \hline
                        wn     & 00       & 0      & 0      & x         & x            & 0      & x       & 00
                        & 00       & 00                                                                              \\
                    \end{tabular}
            }}

            \textbf{ MIEs and OEs}

            \begin{tabular}{cc}
                \textbf{MIE}                                                 & \textbf{OE} \\
                {$
                    \begin{aligned}
                        D_{init}  & = 0                                           \\
                        D_{wg1}   & = Q_{wg1}*roll'+Q_{wn}*roll'                  \\
                        D_{guess} & = Q_{wg1}*roll                                \\
                        D_{wg2}   & = Q_{guess} + Q_{wg2}*roll                    \\
                        D_{wb1}   & = Q_{wg2}*roll'+Q_{wb1}*roll                  \\
                        D_{bet }  & = Q_{wb1}*roll'                               \\
                        D_{wb2}   & = Q_{bet} + Q_{wb2}*roll'                     \\
                        D_{spin}  & = Q_{wb2}roll + Q_{spin}*8E'roll + Q_{load1}  \\
                        D_{load1} & = Q_{spin}*8E*roll                            \\
                        D_{comp}  & = Q_{spin}roll'                               \\
                        D_{win}   & = Q_{comp}*GE                                 \\
                        D_{loose} & = Q_{comp}*GE'                                \\
                        D_{wn2}   & = Q_{wn}*roll + Q_{win}*roll + Q_{loose}*roll
                \end{aligned}$} &
                {$
                    \begin{aligned}
                        Q_{c1}     & = Q_{spin}                       \\
                        Z_{c0}     & = Q_{bet} + Q_{load1}            \\
                        Z_{guess}  & = Q_{guess}                      \\
                        Z_{bet}    & = Q_{init} + Q_{bet}             \\
                        Z_{cmux}   & = Q_{win}+Q_{loose}              \\
                        Z_{bmux}   & = Q_{win}                        \\
                        Z_{cash}   & = Q_{init} + Q_{win} + Q_{loose} \\
                        Z_{addsub} & = Q_{loose}                      \\
                        Z_{led1}   & = Q_{win} + Q_{loose}            \\
                        Z_{led0}   & = Q_{wb1}+Q_{bet}+Q{loose}       \\
                        Z_{rseg1}  & = not (Q_{wg1}+Q_{wb2}+Q_{wn})   \\
                        Z_{rseg0}  & = Q_{init,guess,wg2,wb1,bet,wb2} \\
                        Z_{lseg1}  & = Q_{init}
                \end{aligned}$}
            \end{tabular}
        \end{onlysolution}

    \item \textbf{ (20 pts.)}
        Design a tone generator.  The tone generator is a box with two buttons
        on it labeled ``Up" and ``Down" and a 1-bit output.  At start-up the tone
        generator outputs
        a 440Hz square wave (clock-like signal).  Every time that the Up button
        is pressed the tone generator should increase the frequency of the square
        wave by $\sqrt[12]{2}-1.0 = 0.059463094 \approx 7/128$ of its current frequency.
        To determine the fraction $7/128$ of $X$, shift $X$ left by 7-bits (dividing by
        128) then multiplying it by 4+2+1.  Every time that the down button is pressed
        the circuit should decrease the frequency by 7/128 of its current value.  Assume
        that the master clock frequency of the circuit is 4Mhz.  Turn in
        any relevant calculations, algorithm, datapath and control, control word,
        MIEs, OEs and the maximum tone frequency of the circuit.
        Turn in; an algorithm the datapath and control unit, the control word
        table, the memory input equations, and output equations.
        The control unit is to be implemented using a ones hot encoding.

\end{enumerate}
